package baekjoon._14_bfs_dfs;

public class Main_7562 {
	public static void main(String[] args) {
		// [백준] 7562 나이트의 이동 (그래프와 순회)
		/*
		 * 문제
			체스판 위에 한 나이트가 놓여져 있다. 
			나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 
			나이트가 이동하려고 하는 칸이 주어진다. 
			나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?
			
			입력
			입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.
			각 테스트 케이스는 세 줄로 이루어져 있다. 
			첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 
			체스판의 크기는 l × l이다. 
			체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 
			둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.
			
			출력
			각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.
			
			예제 입력 1 
			3
			8
			0 0
			7 0
			100
			0 0
			30 50
			10
			1 1
			1 1
			
			예제 출력 1 
			5
			28
			0
		 * */
		
		solve();
	}

	static int L = 0; //체스판 크기 (L x L)
	static int[] cur = new int[2]; //(X, Y)일떄, 나이트 현재 위치의 (세로, 가로) 좌표
	static int[] tar = new int[2]; //(X, Y)일떄, 목표 위치의 (세로, 가로) 좌표
	static int[][] map = null;
	
	private static void solve() {
		L = 8;
		cur[0] = 0; cur[1] = 0;
		tar[0] = 7; tar[1] = 0;
		
		map = new int[L][L];
		map[cur[0]][cur[1]] = 1; //시작 
		
		bfs();
	}

	private static void bfs() {
		if(cur[0] == tar[0] && cur[1] == tar[1]) {
			return;
		}
		
		// 현재위치 기준
		// 위, 왼쪽 (-2,-1)    위, 오른쪽(-2, +1)
		// 위, 왼쪽 (-1, -2)   위, 오른쪽(-1, +2)   
		//아래, 왼쪽 (+1, -2)  아래, 오른쪽(+1, +2)
		//아래, 왼쪽 (+2, -1)  아래, 오른쪽(+2, +1)
	}
}
